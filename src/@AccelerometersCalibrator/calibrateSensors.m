function newCalibrationMap = calibrateSensors(...
    ~,calibrationMap,...
    ~,taskSpecificParams,dataPath,...
    measedSensorList,measedPartsList)
%% Comparing the eccentrity of several "grid" dataset measured on the iCub Robot
% This script take dataset in the "grid" format (generated by
% reachRandomJointPositions [1] module) on the iCub robot and compare 
% the eccentrity of the force measurement. In theory the "grid" movement
% is slowly (so the only thing that matters is gravity) moving the legs,
% while the robot is fixed on the pole (so the only external force are 
% on the root_link). In theory then the measured force should be equal 
% to m*g , where g \in R^3 is the gravity expressed in the sensor frame. 
% Hence the measured force should lie on a sphere (eccentrities 0,0) in
% theory. However imperfect sensor can have a different eccentricities (
% but in general they remain linear, so the sphere become an ellipsoid).
% For more on the theory behind this script, check [2].
% [1] : https://github.com/robotology/codyco-modules/tree/master/src/misc/reachRandomJointPositions
% [2] : Traversaro, Silvio, Daniele Pucci, and Francesco Nori. 
%       "In situ calibration of six-axis force-torque sensors using accelerometer measurements."
%       Robotics and Automation (ICRA), 2015 IEEE International Conference on. IEEE, 2015.

% Unwrap task specific parameters (defines 'calibedJointsIdxes')
Init.unWrap(taskSpecificParams);

% Advanced interface parameters
run accelerometersCalibratorDevConfig;

% Build inertial sensors parameters
modelParams = CalibrationContextBuilder.jointsNsensorsDefinitions(...
    measedSensorList,measedPartsList,...
    {},struct([]),struct([]),...  % no need for calibration parts information
    mtbSensorAct);

%% build input data for calibration
%

switch loadSource
    case 'cache'
        load([dataPath '/dataCache.mat'],'data');
        
    case 'dumpFile'
        % build sensor data parser
        plot = false; loadJointPos = false;
        data = SensorsData(dataPath,'',subSamplingSize,...
            timeStart,timeStop,plot);
        [sensorsIdxListFile,sensMeasCell] = data.buildInputDataSet(loadJointPos,ModelParams);
        
        % Save data in a Matlab file for faster access in further runs
        if saveToCache
            save([dataPath '/dataCache.mat'],'data');
        end
        
    otherwise
        disp('Unknown data source !!')
end

%% ========================================== CALIBRATION ==========================================
%
%                          ellipsoid fitting and distance to ellipsoid
%

ellipsoid_p = cell(1,length(sensorsIdxListFile)); % implicit parameters
calib = cell(1,length(sensorsIdxListFile)); % explicit parameters
ellipsoid_e = cell(1,length(sensorsIdxListFile)); % least squares error
ellipsoid_d = cell(1,length(sensorsIdxListFile)); % distance to surface

for acc_i = sensorsIdxListFile
    [ellipsoid_p{acc_i},ellipsoid_e{acc_i},ellipsoid_d{acc_i}] = ellipsoidfit( ...
        sensMeasCell{1,acc_i}(:,1), ...
        sensMeasCell{1,acc_i}(:,2), ...
        sensMeasCell{1,acc_i}(:,3));
    [calib{acc_i}.centre,radii,calib{acc_i}.quat,calib{acc_i}.R] = ...
        ellipsoid_im2ex(ellipsoid_p{1,acc_i}); % convert implicit to explicit
    % convert ellipsoid axis lengths to rates
    calib{acc_i}.radii = radii/9.807;
    % compute full calibration matrix combining elongation and rotation
    calib{acc_i}.C = calib{acc_i}.R'*inv(diag(calib{acc_i}.radii))*calib{acc_i}.R;
    % raw fullscale to m/s^2 conversion
    calib{acc_i}.gain = 5.9855e-04;
end

% Create mapping extension with new calibrated frames
calibratedFrames = data.frames(1,sensorsIdxListFile);
calibMapExt = containers.Map(calibratedFrames,calib);
calibrationMap = [calibrationMap;calibMapExt];

% Return calibration (actually points to the same object. TO BE IMPROVED)
newCalibrationMap = calibrationMap;

end
