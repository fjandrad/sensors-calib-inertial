function runSeq = seqMap2runner( seqParamsMap )
%UNTITLED2 Summary of this function goes here
%   Detailed explanation goes here

%% DEBUG
runSeq.calib.part = {'right_arm','head'};

runSeq.calib.sensors = {{'joint'},{'joint'}};

runSeq.ctrl.part = {'right_arm','head'};

runSeq.ctrl.pos = {...
    [  0 45 -23 50 0 0 0],[0 0 0];...
    [  0 45  49 50 0 0 0],[0 0 0];...
    [  0 45   0 50 0 0 0],[0 0 0];...
    [-20 30 -30 90 0 0 0],[0 0 0];...
    [-20 30 -30  0 0 0 0],[0 0 0];...
    [-20 30 -30 90 0 0 0],[0 0 0];...
    [ 0  45   0 50 0 0 0],[0 0 0];...
    [ 0  45   0 50 0 0 0],[0 0 0]};

runSeq.ctrl.vel = {
    [10 10 10 10 10 10 10],[10 10 10];...
    [10 10 10 10 10 10 10],[10 10 10];...
    [10 10 10 10 10 10 10],[10 10 10];...
    [10 10 10 10 10 10 10],[10 10 10];...
    [10 10 10 10 10 10 10],[10 10 10];...
    [10 10 10 10 10 10 10],[10 10 10];...
    [10 10 10 10 10 10 10],[10 10 10];...
    [10 10 10 10 10 10 10],[10 10 10]};

runSeq.meas.sensor = {'joint','acc','imu'};

runSeq.meas.part = {...
    {'right_arm','torso','head'},...
    {'right_arm'},...
    {'head'}};

runSeq.meas.acquire = {...
    {...
    [true       ,true       ,false      ];...
    [true       ,true       ,true       ];...
    [true       ,true       ,true       ];...
    [false      ,true       ,true       ];...
    [true       ,true       ,false      ];...
    [true       ,true       ,false      ];...
    [false      ,false      ,false      ];...
    [false      ,false      ,false      ]},...
    {...
    [true       ];...
    [true       ];...
    [true       ];...
    [false      ];...
    [true       ];...
    [true       ];...
    [false      ];...
    [false      ]},...
    {...
    [false      ];...
    [true       ];...
    [true       ];...
    [true       ];...
    [false      ];...
    [false      ];...
    [false      ];...
    [false      ]}};


%% CODE TO RECYCLE
% for sequence = sequences
%     % unwrap sequence
%     currSeq = sequence{:};
%     % format sequence for the MotionSequencer runner
%     %seqSets{seq} MotionSequencer.buildSequence(currSeq);
% end
% %cellfun(@(aStruct) aStruct.labels{2},map.values,'UniformOutput', false);
%
%
% % Build sequences: concatenate previous tables depending on 'parts'
% for part = calibedParts
%     % unwrapp part
%     currPart = part{:};
%     % select te target list of sequences
%     setIdx = selector.setIdx(currPart);
%     seqParams = selector.seqParams(currPart);
%     % build the sequence
%     seqSets{setIdx}{2}.part = [seqSets{setIdx}{2}.part currPart];
%     seqSets{setIdx}{2}.pos  = [seqSets{setIdx}{2}.pos seqParams(:,1)];
%     seqSets{setIdx}{2}.vel  = [seqSets{setIdx}{2}.vel seqParams(:,2)];
%     seqSets{setIdx}{2}.acquire  = [seqSets{setIdx}{2}.acquire seqParams(:,3)];
% end
%
% % Run sequence 1 and 2 iteratively then go back to home
% sequences = {};
% for seqSet = seqSets
%     % decapsulate seqSet
%     currentSeqSet = seqSet{:};
%     % concatenate final composition of sequences
%     if ~isempty(currentSeqSet{2}.part)
%         sequences = [sequences;currentSeqSet];
%     end
% end
% sequences = [sequences;homeCalibLimbs];

end

